#version 460
#extension GL_NV_ray_tracing : require
#extension GL_GOOGLE_include_directive : require

#include "utils.glh"

layout(binding = 0, rgba8) uniform writeonly image2D image;
layout(binding = 1) uniform accelerationStructureNV bvh;

layout (std140, binding = 2) readonly uniform UBO
{
	mat4 invR;
	vec4 camPos;
	vec4 lightPos;
	float aspectRatio;
	float fov;
	uint numTasks;
} ubo;

layout(std430, binding = 7) buffer HitBuffer {
    Hit hits[];
};

layout(location = 0) rayPayloadNV PrimaryPayload payload;



float toRad(float deg) {
	return deg * 3.141592 / 360.0;
}

Ray generate_ray(vec2 filmPos) {
    const float scale = tan(toRad(ubo.fov / 2.0));
    vec2 posNDC = filmPos / vec2(gl_LaunchSizeNV.xy);

    vec2 uv = 2.0 * posNDC - 1.0;
    float dirX = -uv.x * scale * ubo.aspectRatio;
    float dirY = uv.y * scale;

    Ray ray;
    ray.origin = ubo.camPos.xyz;
    ray.direction = mat3(ubo.invR) * normalize(vec3(dirX, dirY, 1.0));
    return ray;
}

void main() {
    Ray ray = generate_ray(vec2(gl_LaunchIDNV.xy) + vec2(0.5));
	
	// Gid starts in lower left, grows towards the right
	const uint gid = gl_LaunchIDNV.y * gl_LaunchSizeNV.x + gl_LaunchIDNV.x;
	if (gid > ubo.numTasks)
		return;

	// TODO: shadow/extension/primary flag in ubo

	// https://github.com/KhronosGroup/GLSL/blob/master/extensions/nvx/GLSL_NVX_raytracing.txt
	const uint rayFlags = gl_RayFlagsOpaqueNV;
	traceNV(
		bvh,              // top level accel
		rayFlags,         // rayFlags
		0xff,             // cullMask
		0,                // sbtRecordOffset
		0,                // sbtRecordStride
		0,                // missIndex
		ray.origin,       // origin
		1e-3f,            // tMin
		ray.direction,    // direction
		1e+5f,            // tMax
		0);               // payload idx (for using different payloads)
	
	Hit hit = payload.hit;
	hit.i = (hit.i > -1) ? 1 : -1;
	hits[gid] = hit;
	imageStore(image, ivec2(gl_LaunchIDNV.xy), vec4(payload.color, 1.0));
}